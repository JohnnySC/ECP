Соглашение по стилю написания кода в проекте ECP

Правила именования.

1. Пакеты именуются одним словом строчными буквами (lowercase), либо если нужно написать несколько 
   слов, то слова разделяются знаком подчеркивания (lower_case)
   
2. Классы, интерфейсы именуются начиная с заглавной буквы, если название класса (интерфейса) 
   содержит несколько слов, то каждое слово с заглавной буквы без пробелов и подчеркиваний 
   (SomeClass)
   
3. Функции, поля именуются начиная со строчной буквы, если название функции (поля) содержит 
   несколько слов, то каждое последующее слово с заглавной буквы без пробелов и подчеркиваний 
   (someFunction)
   
4. Неизменяемые поля в (Companion) Object именуются всеми заглавными буквами (UPPER_CASE)
   
5. В названиях функций, полей, классов, интерфейсов не использовать слова get/set. Название должно
   четко определять назначение
   
6. Ресурсы именуются одним словом строчными буквами (lowercase), либо если нужно написать несколько
   слов, то слова разделяются знаком подчеркивания (lower_case)
   
Отступы и форматирование.

1. Нельзя делать разрыв строки перед открывающей скобкой

2. Разрыв строки после открывающей cкобки

3. Разрыв строки перед закрывающей скобкой

4. Разрыв строки после закрывающей скобкой только в том случае, если она заканчивает выражение 
   или тело функции, конструктора, класса.
   
5. С каждом новым блоком отступ увеличивается на 4 пробела. Когда блок закрывается отступ 
   возвращается на предыдущий уровень.
   
6. Каждое выражение разделяется переносом на новую строку (; не используется)

7. Строка кода имеет ограничение в 100 символов. Исключения:
   7.1. Строки, которые невозможно перенести (например: длинный URL)
   7.2. package и import выражения
   7.3. Команды в документации, которые можно вставить в shell 
   
8. Правила для переноса на новую строку:
   8.1. Перенос после оператора или infix функции.
   8.2. Если строка завершается следующими операторами, то перенос осуществляется вместе с ними:
      точка (., .?)
      ссылка на член (::)
      элвис-оператор (:?)
   8.3. Имя метода или конструктура находится на одной строке с открывающей скобкой
   8.4. Запятая (,) связана с элементом и не переносится
   8.5. Стрелка (->) для лямбда-выражений связана с аргументами
   
9. Пустая строка может быть:
   9.1. Между членами классов: свойствами, функциями, конструкторами и другими
   9.2. Пустая строка между двумя свойствами необязательна
   9.3. Между выражениями для логического разделения
   9.4. Перед первым членом функции или класса (необязательно)
   
10. Одиночный пробел:
   10.1. Разделяет зарезервированные слова, таких как: if, for или catch от круглой открывающей скобки:
    
for (i in 1..6) {
} 

   10.2. Разделяет любые зарезервированные слова, таких как else и catch от закрывающей фигурной 
    скобки:

} else {
}

   10.3. Ставится перед любой открывающей фигурной скобкой:

if (items.isEmpty()) {
}

   10.4. Ставится между операндами:

val four = 2 + 2

Исключение: оператор ссылка на член (::), точка (.) или range (..)

   10.5. После двоеточия (:) или запятой (,)

val items = listOf(1, 2)
class Worker: Runnable

Функции.

1. Функции с одним выражение допускается использовать, если она полностью помещается в одну строку

2. Если аргументов функции больше двух, то их необходимо именовать. Также именованные аргументы 
   следует использовать, если функция принимает аргументы одного типа
   
3. Если именованные аргументы не помещаются на одну строку, то каждый аргумент переносится на новую
   строку:

foo (
    argument1 = arg1,
    argument2 = arg2,
    argument3 = arg3
)

4. Именуются аргументы примитивных типов

5. Именуются лямбды, принимаемые функцией в качестве аргументов для того, чтобы было понятно их
назначение
   
6. При написании лямбда-выражения более чем в одну строку, всегда вместо it использовать именованный
   аргумент
   
Классы.

1. Использование именованных аргументов в классах аналогично функциям

2. Структура класса:

    1) Поля: abstract, override, public, internal, protected, private
    2) Блок инициализации: init, конструкторы
    3) Абстрактные методы
    4) Переопределенные методы родительского класса (в том же порядке, в каком они следуют в 
       родительском классе)
    5) Реализации методов интерфейсов (в том же порядке, в каком они следуют в описании класса, 
       соблюдая при этом порядок описания этих методов в самом интерфейсе)
    6) public методы
    7) internal методы
    8) protected методы
    9) private методы
    10) inner классы
    11) companion object

Использование условных операторов.

1. Не обрамлять if выражения в фигурные скобки только если условный оператор if помещается в одну 
   строку.
   
2. В операторе when ветки, состоящие более чем из одной строки, обрамлять фигурными скобками 
   и отделять от других case-веток пустыми строками сверху и снизу:
   
when (type) {

    Type.ONE -> startOne()

    Type.TWO -> startTwo()

    Type.THREE -> {
        startThree()
        showFour()
    }
    
    else -> showError()
}

Аннотации.

1. Аннотации располагаются над описанием класса/поля/метода/аргумента, к которому они применяются.
   Если к классу/полю/методу применяется несколько аннотаций, размещать каждую аннотацию 
   с новой строки. 
   
@JsonValue
@JvmField
var item: Item? = null

2. Eсли аннотаций к одному аргументу несколько, то все аннотации пишутся с новой строки, и 
   соответствующий аргумент отделяется от других сверху и снизу пустыми строками.

@Entity(tableName = "users")
data class UserInfo (
@PrimaryKey val id: Int,

    @SerializedName("firstName") 
    @ColumnInfo(name = "firstName") 
    val firstName: String? = null,
    
    @SerializedName("secondName") 
    @ColumnInfo(name = "secondName") 
    val secondName: String? = null
)
