Соглашение по стилю написания кода в проекте ECP

Правила именования.

1. Пакеты именуются одним словом строчными буквами (lowercase), либо если нужно написать несколько 
   слов, то слова разделяются знаком подчеркивания (lower_case)
   
2. Классы, интерфейсы именуются начиная с заглавной буквы, если название класса (интерфейса) 
   содержит несколько слов, то каждое слово с заглавной буквы без пробелов и подчеркиваний 
   (SomeClass)
   
3. Функции, поля именуются начиная со строчной буквы, если название функции (поля) содержит 
   несколько слов, то каждое последующее слово с заглавной буквы без пробелов и подчеркиваний 
   (someFunction)
   
4. Неизменяемые поля в (Companion) Object именуются всеми заглавными буквами (UPPER_CASE)
   
5. В названиях функций, полей, классов, интерфейсов не использовать слова get/set. Название должно
   четко определять назначение
   
Функции.

1. Функции с одним выражение допускается использовать, если она полностью помещается в одну строку

2. Если аргументов функции больше двух, то их необходимо именовать. Также именованные аргументы 
   следует использовать, если функция принимает аргументы одного типа
   
3. Если именованные аргументы не помещаются на одну строку, то каждый аргумент переносится на новую
   строку:

foo (
    argument1 = arg1,
    argument2 = arg2,
    argument3 = arg3
)

4. Именуются аргументы примитивных типов

5. Именуются лямбды, принимаемые функцией в качестве аргументов для того, чтобы было понятно их
назначение
   
6. При написании лямбда-выражения более чем в одну строку, всегда вместо it использовать именованный
   аргумент
   
Классы.

1. Использование именованных аргументов в классах аналогично функциям

2. Структура класса:

    1) Поля: abstract, override, public, internal, protected, private
    2) Блок инициализации: init, конструкторы
    3) Абстрактные методы
    4) Переопределенные методы родительского класса (в том же порядке, в каком они следуют в 
       родительском классе)
    5) Реализации методов интерфейсов (в том же порядке, в каком они следуют в описании класса, 
       соблюдая при этом порядок описания этих методов в самом интерфейсе)
    6) public методы
    7) internal методы
    8) protected методы
    9) private методы
    10) inner классы
    11) companion object

Использование условных операторов.

1. Не обрамлять if выражения в фигурные скобки только если условный оператор if помещается в одну 
   строку.
   
2. В операторе when ветки, состоящие более чем из одной строки, обрамлять фигурными скобками 
   и отделять от других case-веток пустыми строками сверху и снизу:
   
when (type) {
    Type.ONE -> startOne()

    Type.TWO -> startTwo()

    Type.THREE -> {
        startThree()
        showFour()
    }
    
    else -> showError()
}

Аннотации.

1. Аннотации располагаются над описанием класса/поля/метода/аргумента, к которому они применяются.
   Если к классу/полю/методу применяется несколько аннотаций, размещать каждую аннотацию 
   с новой строки. 
   
@JsonValue
@JvmField
var item: Item? = null

2. Eсли аннотаций к одному аргументу несколько, то все аннотации пишутся с новой строки, и 
   соответствующий аргумент отделяется от других сверху и снизу пустыми строками.

@Entity(tableName = "users")
data class UserInfo (
@PrimaryKey val id: Int,

    @SerializedName("firstName") 
    @ColumnInfo(name = "firstName") 
    val firstName: String? = null,
    
    @SerializedName("secondName") 
    @ColumnInfo(name = "secondName") 
    val secondName: String? = null
)
